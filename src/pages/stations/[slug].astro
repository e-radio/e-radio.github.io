---
import Layout from "../../layouts/Layout.astro";
import SEO from "../../components/SEO.astro";
import rawStations from "../../data/stations-gr.json";
import { slugify } from "../../lib/slug";
import { Image } from "astro:assets";


export async function getStaticPaths() {
  return rawStations.map((station) => ({
    params: { slug: station.slug },
    props: { station },
  }));
}

interface Props {
  station: typeof rawStations[0];
}

const radddioURL = "https://apple.co/4lNPQAH";
const radioAppIconUrl = "/radddio-app-icon.png";
const radddioBadgeUrl = "/radddio-badge.svg";
const { station } = Astro.props;

const hasStream = Boolean(station.stream_url);
const formattedVotes = station.votes ? new Intl.NumberFormat("en-US").format(Number(station.votes)) : null;
const locationLabel = station.state
  ? `${station.state}${station.country ? `, ${station.country}` : ""}`
  : station.country || "Greece";
const genres = (station.genres || []).filter(Boolean);
const displayGenres = genres.slice(0, 3);
const streamQualityParts = [
  station.codec ? String(station.codec).toUpperCase() : null,
  station.bitrate ? `${station.bitrate} kbps` : null,
].filter(Boolean);
const streamQualityLabel = streamQualityParts.join(" · ");
const streamDetailMeta = [
  station.codec ? `Codec: ${String(station.codec).toUpperCase()}` : null,
  station.bitrate ? `Bitrate: ${station.bitrate} kbps` : null,
  station.hls ? "Stream type: HLS" : null,
]
  .filter(Boolean)
  .join(" · ");
const languageLabel = station.language ? station.language : null;
const streamUrl = station.stream_url || "";

const AZURACAST_NOW_PLAYING_OVERRIDES: Record<string, string> = {
  "disco-cafe-athens": "https://azuracast.streams.ovh/api/nowplaying/discocafe",
  "emerson-athens-athens": "https://azuracast.streams.ovh/api/nowplaying/radioemerson",
  "energy-radio-greece": "https://azuracast.streams.ovh/api/nowplaying/energy",
  "freespirits-services": "https://aphrodite.freespirits.gr/api/nowplaying/freespirits_radio",
  "kaseta-radio": "https://azuracast.streams.gr/api/nowplaying/kasetaradio",
  "kyklos": "https://azuracast.streams.ovh/api/nowplaying/radiokyklos",
  "radio-kyklos": "https://azuracast.streams.ovh/api/nowplaying/radiokyklos",
  "radiokyklos-greek-hiphop": "https://azuracast.streams.ovh/api/nowplaying/radiokyklos",
  "rock-angels-athens": "https://azuracast.streams.ovh/api/nowplaying/rockangels",
  "rock-angels": "https://azuracast.streams.ovh/api/nowplaying/rockangels",
  "rock-angels-radio": "https://azuracast.streams.ovh/api/nowplaying/rockangels",
  "studio-545": "https://azuracast.streams.ovh/api/nowplaying/studio_545",
  "vips-radio-athens-athens": "https://azuracast.streams.gr/api/nowplaying/vipsradio",
  "live-thessaloniki": "https://azuracast.streams.gr/api/nowplaying/paulosvasileioulive",
};

const wrapWithCorsProxy = (rawUrl: string) => {
  if (!rawUrl) return rawUrl;
  if (/^https:\/\/r\.jina\.ai\//i.test(rawUrl)) {
    return rawUrl;
  }
  const normalized = rawUrl.replace(/^https?:\/\//i, (protocol) => protocol.toLowerCase());
  return `https://r.jina.ai/${normalized}`;
};

type ServerKind =
  | "azuracast"
  | "centovacast"
  | "shoutcast"
  | "icecast"
  | "radio.co"
  | "unknown";

const resolveMetadataEndpoints = (inputStreamUrl: string | undefined, stationData: typeof rawStations[0]) => {
  const overridden = AZURACAST_NOW_PLAYING_OVERRIDES[stationData.slug];
  if (overridden) {
    return { nowPlaying: overridden, history: null, serverType: "azuracast" as ServerKind };
  }

  if (!inputStreamUrl) {
    return { nowPlaying: null, history: null, serverType: "unknown" as ServerKind };
  }

  let nowPlaying: string | null = null;
  let history: string | null = null;
  let serverType: ServerKind = "unknown";

  try {
    const url = new URL(inputStreamUrl);
    const hostname = url.hostname.toLowerCase();
    const pathnameSegments = url.pathname.split("/").filter(Boolean);
    const lowerSegments = pathnameSegments.map((segment) => segment.toLowerCase());

    const firstNumericSegment = pathnameSegments.find((segment) => /^\d+$/.test(segment));
    const portFromPath = firstNumericSegment && Number(firstNumericSegment) > 32 ? firstNumericSegment : null;
    const pathLower = url.pathname.toLowerCase();
    const isStreamsOvhHost = /streams\.ovh$/i.test(hostname);
    const isStreamsOvhINode = /^i\d+\.streams\.ovh$/.test(hostname);
    const usesShoutcastStylePath = pathLower.includes(";");
    const hasListenPls = pathLower.includes("listen.pls") || pathLower.endsWith(".pls");
    const hasShoutcastQuery = url.searchParams.has("sid") || url.searchParams.has("type") || url.searchParams.has("icy");
    const hasShoutcastIndicators = usesShoutcastStylePath || hasListenPls || hasShoutcastQuery;

    const sidFromQuery = url.searchParams.get("sid");
    const sidFromPath = pathnameSegments.find((segment) => /^sid\d+$/i.test(segment));
    const numericSidSegment = pathnameSegments.find((segment) => {
      if (!/^\d+$/.test(segment)) return false;
      if (segment === portFromPath) return false;
      return Number(segment) <= 32;
    });

    const guessShoutcastSid = () => {
      if (sidFromQuery && /^\d+$/.test(sidFromQuery)) {
        return sidFromQuery;
      }
      if (sidFromPath) {
        const extracted = sidFromPath.replace(/[^0-9]/g, "");
        if (extracted) return extracted;
      }
      if (numericSidSegment) {
        return numericSidSegment;
      }
      return "1";
    };

    const resolveShoutcastBase = () => {
      const portValue = url.port || portFromPath;
      if (portValue) {
        return `${url.protocol}//${hostname}:${portValue}`;
      }
      return url.origin;
    };

    const sanitizeMount = (segment: string | undefined | null) => {
      if (!segment) return null;
      const cleaned = segment.split(/[.;?]/)[0];
      return cleaned ? cleaned.trim() : null;
    };

    const deriveIcecastMount = () => {
      const mpParam = url.searchParams.get("mp") || url.searchParams.get("mount");
      if (mpParam) {
        return mpParam.startsWith("/") ? mpParam : `/${mpParam}`;
      }

      const icIndex = lowerSegments.indexOf("ic");
      if (icIndex !== -1 && pathnameSegments[icIndex + 1]) {
        return `/${pathnameSegments[icIndex + 1]}`;
      }

      if (pathnameSegments.length > 0) {
        const last = pathnameSegments[pathnameSegments.length - 1];
        const secondLast = pathnameSegments[pathnameSegments.length - 2];
        if (last && last !== "stream" && !last.includes(".")) {
          return `/${last}`;
        }
        if (last === "stream" && secondLast && secondLast !== "ic") {
          return `/${secondLast}`;
        }
      }

      return "/stream";
    };

    const looksLikeIcecast = () => {
      if (hostname.startsWith("ice.")) return true;
      if (hostname.includes(".ice.")) return true;
      if (lowerSegments.includes("ic")) return true;
      if (url.searchParams.has("mp") || url.searchParams.has("mount")) return true;
      if (pathnameSegments.some((segment) => segment.endsWith(".ogg") || segment.endsWith(".opus"))) return true;
      if (isStreamsOvhINode && !hasShoutcastIndicators) return true;
      return false;
    };

    if (isStreamsOvhHost) {
      const mountCarrierIndex = lowerSegments.findIndex((segment) => ["sc", "ssl", "ic"].includes(segment));
      if (mountCarrierIndex !== -1) {
        const mount = sanitizeMount(pathnameSegments[mountCarrierIndex + 1]);
        if (mount) {
          const baseRpc = `https://${hostname}:2199/rpc/${mount}`;
          nowPlaying = wrapWithCorsProxy(`${baseRpc}/streaminfo.get`);
          serverType = "centovacast";
          return { nowPlaying, history, serverType };
        }
      }

      if (looksLikeIcecast()) {
        const mount = deriveIcecastMount();
        const base = url.port ? `${url.protocol}//${hostname}:${url.port}` : url.origin;
        const encodedMount = encodeURIComponent(mount);
        nowPlaying = wrapWithCorsProxy(`${base}/status-json.xsl?mount=${encodedMount}`);
        history = wrapWithCorsProxy(`${base}/status.xsl?mount=${encodedMount}`);
        serverType = "icecast";
        return { nowPlaying, history, serverType };
      }

      const sid = guessShoutcastSid();
      const portValue = url.port || portFromPath;
      if (portValue) {
        const base = `${url.protocol}//${hostname}:${portValue}`;
        nowPlaying = wrapWithCorsProxy(`${base}/stats?sid=${sid}&json=1`);
        history = wrapWithCorsProxy(`${base}/played.html?sid=${sid}`);
        serverType = "shoutcast";
        return { nowPlaying, history, serverType };
      }
    }

    const isLikelyShoutcastHost = /radiohost|shoutca\.st|radioca\.st|myradiostream|onweb\.gr|streamwithq|fastcast4u|magicstreams|viastreaming|dedicateware|proradio|viastream/i.test(hostname);

    if (isLikelyShoutcastHost || hasShoutcastIndicators) {
      const sid = guessShoutcastSid();
      const base = resolveShoutcastBase();
      nowPlaying = wrapWithCorsProxy(`${base}/stats?sid=${sid}&json=1`);
      history = wrapWithCorsProxy(`${base}/played.html?sid=${sid}`);
      serverType = "shoutcast";
      return { nowPlaying, history, serverType };
    }

    if (hostname.includes("radio.co")) {
      const match = pathnameSegments.find((segment) => /^s[a-z0-9]{9}$/i.test(segment));
      if (match) {
        nowPlaying = `https://public.radio.co/station/${match}/nowplaying`;
        serverType = "radio.co";
        return { nowPlaying, history, serverType };
      }
    }

    if (hostname.includes("azuracast")) {
      const listenIndex = pathnameSegments.indexOf("listen");
      if (listenIndex !== -1 && pathnameSegments[listenIndex + 1]) {
        const shortName = pathnameSegments[listenIndex + 1];
        nowPlaying = `${url.origin}/api/nowplaying/${shortName}`;
        serverType = "azuracast";
        return { nowPlaying, history, serverType };
      }

      const publicSlug = stationData.homepage && stationData.homepage.includes("/public/")
        ? stationData.homepage.split("/").filter(Boolean).pop() ?? null
        : null;

      if (publicSlug) {
        nowPlaying = `${url.origin}/api/nowplaying/${publicSlug}`;
        serverType = "azuracast";
        return { nowPlaying, history, serverType };
      }

      const sanitize = (value: string | null | undefined) =>
        (value || "").toLowerCase().replace(/[^a-z0-9]+/g, "");
      const nameCandidate = sanitize(stationData.name);
      if (nameCandidate) {
        nowPlaying = `${url.origin}/api/nowplaying/${nameCandidate}`;
        serverType = "azuracast";
        return { nowPlaying, history, serverType };
      }

      const slugCandidate = sanitize(stationData.slug);
      if (slugCandidate) {
        nowPlaying = `${url.origin}/api/nowplaying/${slugCandidate}`;
        serverType = "azuracast";
        return { nowPlaying, history, serverType };
      }
    }
  } catch (error) {
    /* no-op */
  }

  return { nowPlaying, history, serverType };
};

const {
  nowPlaying: nowPlayingEndpoint,
  history: historyEndpoint,
  serverType,
} = resolveMetadataEndpoints(streamUrl, station);

// Get recommended stations based on genre and location
const getRecommendedStations = () => {
  const recommended: typeof rawStations = rawStations
    .filter((s: typeof rawStations[0]) => s.slug !== station.slug) // Exclude current station
    .map((s: typeof rawStations[0]) => {
      let score = 0;
      // Genre match (highest priority)
      if (station.genres.some((g: string) => (s.genres as string[]).includes(g))) {
        score += 10;
      }
      // Same state (medium priority)
      if (station.state && s.state === station.state) {
        score += 5;
      }
      // Same country (lowest priority)
      if (s.country === station.country) {
        score += 1;
      }
      return { station: s, score };
    })
    .filter((item) => item.score > 0) // Only stations with some relevance
    .sort((a, b) => {
      // Sort by score first, then by votes
      if (b.score !== a.score) return b.score - a.score;
      return (b.station.votes || 0) - (a.station.votes || 0);
    })
    .slice(0, 5) // Get top 5
    .map((item) => item.station);

  return recommended;
};

const recommendedStations = getRecommendedStations();

const siteRoot = "https://e-radio.github.io";
const canonical = `${siteRoot}/stations/${station.slug}/`;
const ogImage = "/e-radio-og-image.png";
const ogImageUrl = station.favicon && station.favicon.startsWith("http")
  ? station.favicon
  : station.favicon
    ? `${siteRoot}${station.favicon}`
    : `${siteRoot}${ogImage}`;

const resolveEncodingFormat = (currentStation: typeof rawStations[0]) => {
  const streamUrl = String(currentStation.stream_url ?? "").toLowerCase();
  const codec = String(currentStation.codec ?? "").toLowerCase();

  if (currentStation.hls || streamUrl.includes(".m3u8")) {
    return "application/vnd.apple.mpegurl";
  }

  switch (codec) {
    case "mp3":
    case "mpeg":
    case "audio/mpeg":
      return "audio/mpeg";
    case "aac":
    case "aac+":
    case "aacplus":
    case "aacp":
    case "audio/aac":
      return "audio/aac";
    case "ogg":
    case "oga":
      return "audio/ogg";
    case "opus":
      return "audio/opus";
    case "flac":
      return "audio/flac";
    case "wav":
      return "audio/wav";
    case "wma":
      return "audio/x-ms-wma";
    default:
      break;
  }

  if (streamUrl.endsWith(".aac")) {
    return "audio/aac";
  }
  if (streamUrl.endsWith(".mp3")) {
    return "audio/mpeg";
  }
  if (streamUrl.endsWith(".ogg") || streamUrl.endsWith(".oga")) {
    return "audio/ogg";
  }

  return undefined;
};

const encodingFormat = resolveEncodingFormat(station);

const title = `${station.name} – Live Radio Station in Greece | E-Radio`;
const genreLabel = station.genres.length > 0
  ? station.genres.slice(0, 2).join(", ").toLowerCase()
  : "live";
const description = station.state
  ? `Listen to ${station.name} live from ${station.state}, Greece. Stream ${genreLabel} radio online with reliable playback, station details, and the latest stream quality info.`
  : `Listen to ${station.name} live from Greece. Stream ${genreLabel} radio online with reliable playback, station details, and the latest stream quality info.`;

const playerScriptConfig = {
  hasStream,
  streamUrl,
  shareTitle: station.name,
  shareText: `Listen live: ${station.name}`,
  shareUrl: canonical,
  nowPlayingEndpoint,
  historyEndpoint,
  serverType,
};

// Structured data (JSON-LD)
const structuredData = {
  "@context": "https://schema.org",
  "@type": "RadioStation",
  "@id": `${canonical}#radiostation`,
  "name": station.name,
  "url": canonical,
  "description": description,
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": canonical
  },
  "image": ogImageUrl,
  "logo": ogImageUrl,
  "identifier": station.stationuuid,
  ...(station.homepage ? { "sameAs": [station.homepage] } : {}),
  ...(station.state
    ? {
        "areaServed": {
          "@type": "AdministrativeArea",
          "name": station.state,
          "containedInPlace": {
            "@type": "Country",
            "name": station.country || "Greece",
            "identifier": String(station.countrycode || "GR").toUpperCase()
          }
        }
      }
    : {
        "areaServed": {
          "@type": "Country",
          "name": station.country || "Greece",
          "identifier": String(station.countrycode || "GR").toUpperCase()
        }
      }),
  ...(station.stream_url
    ? {
        "subjectOf": {
          "@type": "AudioObject",
          "name": `${station.name} Live Stream`,
          "contentUrl": station.stream_url,
          ...(encodingFormat ? { "encodingFormat": encodingFormat } : {}),
          ...(station.language ? { "inLanguage": station.language } : {}),
          ...(station.genres.length > 0 ? { "genre": station.genres } : {})
        }
      }
    : {})
};
---

<Layout title={title} description={description} bodyClass="station-detail-body">
  <!-- SEO Meta Tags -->
  <SEO 
    slot="seo"
    title={title}
    description={description}
    canonical={canonical}
    ogTitle={title}
    ogDescription={description}
    ogImage={ogImageUrl}
    ogType="music.radio_station"
    keywords={`${station.name}, ${station.state || "Greece"}, radio, live, ${station.genres.join(", ")}`}
    robots="index, follow"
    author="E-Radio Greece"
    structuredData={structuredData}
  />
  <div class="d-flex align-items-center justify-content-between flex-wrap gap-2 mb-4">
    <nav aria-label="Breadcrumb">
      <ol class="breadcrumb mb-0 bg-transparent p-0">
        <li class="breadcrumb-item"><a href="/">All Stations</a></li>
        <li class="breadcrumb-item active" aria-current="page">{station.name}</li>
      </ol>
    </nav>
    <div class="small-muted">
      Updated {new Date().toLocaleDateString("en-US", { year: "numeric", month: "short", day: "numeric" })}
    </div>
  </div>

  <div class="row g-4">
    <div class="col-12 col-lg-8">
      <section class="glass rounded-3 p-3 p-md-4">
        <div class="d-flex align-items-start justify-content-between gap-3 align-items-center">
          <div class="d-flex align-items-start gap-3">
            {station.favicon ? (
              <img
                class="station-cover shadow-sm"
                src={station.favicon}
                alt={`${station.name} logo`}
                loading="lazy"
              />
            ) : (
              <img
                class="station-cover shadow-sm"
                src={radioAppIconUrl}
                alt="Radddio app icon"
                loading="lazy"
              />
            )}
            <div class="pt-1">
              <div class="d-flex align-items-center flex-wrap gap-2 mb-2">
                <h1 class="h4 fw-bold mb-0">{station.name}</h1>
                {hasStream && <span class="badge rounded-pill badge-soft">Live</span>}
                {hasStream && <span class="badge rounded-pill text-bg-light border">Verified stream</span>}
              </div>
              <div class="d-flex flex-wrap gap-2 gap-md-3 small-muted">
                {locationLabel && (
                  <span><i class="bi bi-geo-alt me-1"></i>{locationLabel}</span>
                )}
                {displayGenres.length > 0 && (
                  <span><i class="bi bi-music-note-beamed me-1"></i>{displayGenres.join(", ")}</span>
                )}
                {formattedVotes && (
                  <span><i class="bi bi-bar-chart me-1"></i>{formattedVotes} votes</span>
                )}
              </div>
            </div>
          </div>
        </div>

        <hr class="my-4" />

        {hasStream ? (
          <div class="row g-3 align-items-center">
            <div class="col-12">
              <div class="d-flex align-items-center justify-content-between flex-wrap gap-2">
                <div class="d-flex align-items-center gap-2">
                  <button class="btn btn-primary rounded-pill px-4" id="btnPlay" type="button">
                    <i class="bi bi-play-fill me-1"></i> Play
                  </button>

                  <button class="btn btn-outline-secondary rounded-pill" id="btnStop" type="button">
                    <i class="bi bi-stop-fill me-1"></i> Stop
                  </button>

                  <div class="d-none d-sm-flex align-items-center gap-2 ms-1">
                    <i class="bi bi-volume-up"></i>
                    <input
                      id="volume"
                      class="form-range volume-range"
                      type="range"
                      min="0"
                      max="1"
                      step="0.01"
                      value="1"
                      aria-label="Volume"
                    />
                  </div>
                </div>

                <div class="d-flex flex-wrap gap-2">
                  <span class="badge rounded-pill text-bg-light border">
                    <i class="bi bi-soundwave me-1"></i>
                    <span class="mono" id="quality">{streamQualityLabel || "Quality not reported"}</span>
                  </span>
                  <span class="badge rounded-pill text-bg-light border">
                    <i class="bi bi-wifi me-1"></i>
                    <span id="statusText">Idle</span>
                  </span>
                </div>
              </div>
            </div>

            <div class="col-12">
              <div class="progress progress-thin" role="progressbar" aria-label="Buffer status">
                <div class="progress-bar" id="bufferBar" style="width: 0%"></div>
              </div>
              <div class="d-flex justify-content-between mt-2 small-muted">
                <span id="nowPlayingLabel">Now playing: <span class="text-dark" id="nowPlaying">{station.name}</span></span>
                <span class="mono" id="timeHint">00:00</span>
              </div>
            </div>

            <div class="col-12">
              <audio
                id="audio"
                preload="none"
                crossorigin="anonymous"
                src={streamUrl}
              >
                Your browser does not support the audio element.
              </audio>
            </div>
          </div>
        ) : (
          <div class="text-center py-4">
            <p class="small-muted mb-3">Stream is currently unavailable.</p>
            <div class="d-flex justify-content-center flex-wrap gap-2">
              <a class="btn btn-outline-primary rounded-pill" href={radddioURL} target="_blank" rel="nofollow noopener" aria-label={`Listen to ${station.name} on Radddio App`}>
                <i class="bi bi-broadcast-pin me-1"></i> Listen on Radddio
              </a>
              {station.homepage && (
                <a class="btn btn-outline-secondary rounded-pill" href={station.homepage} target="_blank" rel="noopener">
                  <i class="bi bi-globe2 me-1"></i> Visit website
                </a>
              )}
            </div>
          </div>
        )}

        {hasStream && (
          <div class="d-flex flex-wrap justify-content-center mt-4">
            <div class="text-center">
              <a
                href={radddioURL}
                class="text-decoration-none radddio-badge"
                target="_blank"
                rel="nofollow noopener"
                aria-label={`Listen to ${station.name} on Radddio App`}
              >
                <Image src={radddioBadgeUrl} alt="Radddio app badge" width={144} height={47} />
              </a>
            </div>
          </div>
        )}
      </section>

      <section class="glass rounded-3 p-3 p-md-4 mt-4">
        <div class="d-flex align-items-center justify-content-between mb-3">
          <h2 class="h6 fw-bold mb-0"><i class="bi bi-disc me-2"></i> Recently played</h2>
          <span class="small-muted" id="recently-played-hint">Waiting for station metadata…</span>
        </div>
        <div class="row g-3" id="recently-played">
          <div class="col-12 col-md-6">
            <div class="p-3 bg-white rounded-3 border border-light-subtle h-100">
              <div class="small-muted mb-1">Previous</div>
              <div class="fw-semibold" id="recent-previous-title">Waiting for metadata</div>
              <div class="small-muted" id="recent-previous-meta">Tune in to update</div>
            </div>
          </div>
          <div class="col-12 col-md-6">
            <div class="p-3 bg-white rounded-3 border border-light-subtle h-100">
              <div class="small-muted mb-1">Up next</div>
              <div class="fw-semibold" id="recent-next-title">Waiting for metadata</div>
              <div class="small-muted" id="recent-next-meta">Tune in to update</div>
            </div>
          </div>
        </div>
        <div class="mt-3 pt-3 border-top border-light-subtle">
          <div class="small-muted mb-2">Song history</div>
          <ul class="list-unstyled mb-0 small" id="recent-history" data-default-message="Waiting for station metadata…">
            <li class="small-muted">Waiting for station metadata…</li>
          </ul>
        </div>
      </section>
      {recommendedStations.length > 0 && (
    <section class="glass rounded-3 p-3 p-md-4 mt-4">
      <h2 class="h6 fw-bold mb-3"><i class="bi bi-broadcast-pin me-2"></i>More stations</h2>
      <div class="station-list border border-light-subtle rounded-3 overflow-hidden">
        {recommendedStations.map((recStation, index) => (
          <div class={`station-item position-relative ${index !== recommendedStations.length - 1 ? 'border-bottom border-light-subtle' : ''}`} itemscope itemtype="https://schema.org/RadioStation">
            <a href={`/stations/${recStation.slug}/`} class="stretched-link" aria-label={`Go to ${recStation.name}`} itemprop="url"></a>
            <div class="station-item-body p-3">
              <div class="row align-items-center g-3">
                <div class="col-auto">
                  {recStation.favicon ? (
                    <Image src={recStation.favicon} alt={`${recStation.name} logo`} class="rounded station-logo" width={60} height={60} itemprop="image" />
                  ) : (
                    <Image src={radioAppIconUrl} alt="Radddio app icon" class="rounded station-logo" width={60} height={60} itemprop="image" />
                  )}
                </div>
                <div class="col flex-grow-1">
                  <h3 class="mb-1 fs-6 fw-bold text-dark" itemprop="name">{recStation.name}</h3>
                  <p class="small text-muted mb-1">
                    {recStation.state ? <span><i class="bi bi-geo-alt me-1"></i>{recStation.state}</span> : null}
                    {recStation.bitrate ? <span class="ms-2"><i class="bi bi-soundwave me-1"></i>{recStation.bitrate} kbps</span> : null}
                  </p>
                  <div class="d-flex gap-2 flex-wrap">
                    {recStation.genres && recStation.genres.slice(0, 3).map((genre) => (
                      <a
                        href={`/genres/${slugify(genre)}/`}
                        class="badge bg-secondary-subtle text-secondary-emphasis rounded-pill text-decoration-none genre-badge-link"
                      >
                        {genre}
                      </a>
                    ))}
                  </div>
                </div>
                <div class="col-auto text-end d-md-block">
                  <a href={radddioURL} class="text-decoration-none radddio-badge" target="_blank" rel="nofollow noopener" aria-label={`Listen to ${recStation.name} on Radddio App`}><Image src={radddioBadgeUrl} alt="Radddio app badge" width={144} height={47} /></a>
                </div>
              </div>
            </div>
          </div>
        ))}
      </div>
    </section>
  )}
    </div>

    <div class="col-12 col-lg-4">
      <aside id="details" class="glass rounded-3 p-3 p-md-4">
        <h2 class="h6 fw-bold mb-3"><i class="bi bi-card-text me-2"></i>Station details</h2>

        <div class="vstack gap-3">
          {station.stationuuid && (
            <div>
              <div class="small-muted mb-1">Station ID</div>
              <div class="mono">{station.stationuuid}</div>
            </div>
          )}

          {hasStream && (
            <div>
              <div class="small-muted mb-1">Stream URL</div>
              <a class="mono link-muted d-block text-truncate" href={streamUrl} target="_blank" rel="noopener">
                {streamUrl}
              </a>
            </div>
          )}

          {hasStream && (
            <div>
              <div class="d-flex align-items-center justify-content-between mb-2">
                <div>
                  <div class="small-muted">Stream quality</div>
                  <div class="fw-semibold">{streamQualityLabel || "Not reported"}</div>
                </div>
                <i class="bi bi-soundwave fs-4 text-primary"></i>
              </div>
              {streamDetailMeta && <div class="small-muted">{streamDetailMeta}</div>}
            </div>
          )}

          {genres.length > 0 && (
            <div>
              <div class="small-muted mb-2">Genres</div>
              <div class="d-flex flex-wrap gap-2">
                {genres.map((genre) => (
                  <a class="badge rounded-pill text-bg-light border text-decoration-none" href={`/genres/${slugify(genre)}/`}>
                    {genre}
                  </a>
                ))}
              </div>
            </div>
          )}

          <div>
            <div class="small-muted mb-2">Popularity</div>
            <div class="d-flex align-items-center justify-content-between">
              <div>
                <div class="fw-semibold" id="votes">{formattedVotes ? `${formattedVotes} votes` : "No votes recorded"}</div>
                <div class="small-muted">Updated daily</div>
              </div>
              <button class="btn btn-outline-primary rounded-pill btn-sm" type="button" id="btnVote">
                <i class="bi bi-hand-thumbs-up me-1"></i> Vote
              </button>
            </div>
          </div>

          <div>
            <div class="small-muted mb-2">Location</div>
            <div class="fw-semibold">{locationLabel}</div>
            <div class="small-muted">
              Country: {station.country || "Greece"}
              {languageLabel && <> · Language: {languageLabel}</>}
            </div>
          </div>

          <div>
            <div class="small-muted mb-2">More</div>
            <div class="d-grid gap-1">
              <a href="/" class="text-decoration-none">Browse Greece Stations</a>
              <a href={radddioURL} target="_blank" rel="nofollow noopener" class="text-decoration-none" aria-label={`Listen to ${station.name} on Radddio App`}>Listen on Radddio</a>
              {station.homepage && (
              <a href={station.homepage} target="_blank" rel="noopener" class="text-decoration-none">Station Website</a>
               )}
              <button id="btnCopyLink" type="button" class="btn btn-link p-0 text-decoration-none text-start text-secondary">Copy Link</button>
            <a class="text-decoration-none text-secondary" href={streamUrl} target="_blank" rel="noopener">Open Stream</a>
            <button class="btn btn-link p-0 text-danger text-decoration-none text-start" id="btnReport" type="button">Report Stream Issue</button>
            </div>
          </div>
        </div>
      </aside>

      <section class="glass rounded-3 p-3 p-md-4 mt-4">
        <h2 class="h6 fw-bold mb-3"><i class="bi bi-question-circle me-2"></i>Useful Tips</h2>
        <ul class="small-muted mb-0">
          <li>If playback stops, try switching networks or refresh the page.</li>
          <li>Some stations limit connections; retry after 10–30 seconds.</li>
          <li>Prefer streams 128 kbps or higher for best quality.</li>
        </ul>
      </section>
    </div>
  </div>

  <div id="player-config" data-config={JSON.stringify(playerScriptConfig)} hidden></div>
  <script>
// @ts-nocheck
    const configEl = document.getElementById('player-config');
    const defaultConfig = {
      hasStream: false,
      streamUrl: '',
      shareTitle: document.title,
      shareText: document.title,
      shareUrl: window.location.href,
      nowPlayingEndpoint: null,
      historyEndpoint: null,
      serverType: "unknown",
    };
    const playerConfig = {
      ...defaultConfig,
      ...(configEl instanceof HTMLElement ? JSON.parse(configEl.dataset.config || '{}') : {}),
    };
    if (configEl instanceof HTMLElement) {
      configEl.remove();
    }

    const audio = /** @type {HTMLAudioElement | null} */ (document.getElementById('audio'));
    const btnPlay = /** @type {HTMLButtonElement | null} */ (document.getElementById('btnPlay'));
    const btnStop = /** @type {HTMLButtonElement | null} */ (document.getElementById('btnStop'));
    const statusText = /** @type {HTMLElement | null} */ (document.getElementById('statusText'));
    const bufferBar = /** @type {HTMLElement | null} */ (document.getElementById('bufferBar'));
    const volume = /** @type {HTMLInputElement | null} */ (document.getElementById('volume'));
    const timeHint = /** @type {HTMLElement | null} */ (document.getElementById('timeHint'));
    const btnCopyLink = /** @type {HTMLButtonElement | null} */ (document.getElementById('btnCopyLink'));
    const btnReport = /** @type {HTMLButtonElement | null} */ (document.getElementById('btnReport'));
    const btnShare = /** @type {HTMLButtonElement | null} */ (document.getElementById('btnShare'));
    const btnFavorite = /** @type {HTMLButtonElement | null} */ (document.getElementById('btnFavorite'));
    const btnVote = /** @type {HTMLButtonElement | null} */ (document.getElementById('btnVote'));
    const nowPlayingEl = /** @type {HTMLElement | null} */ (document.getElementById('nowPlaying'));
    const nowPlayingDefault = nowPlayingEl?.textContent || '';
    const previousTitleEl = /** @type {HTMLElement | null} */ (document.getElementById('recent-previous-title'));
    const previousMetaEl = /** @type {HTMLElement | null} */ (document.getElementById('recent-previous-meta'));
    const nextTitleEl = /** @type {HTMLElement | null} */ (document.getElementById('recent-next-title'));
    const nextMetaEl = /** @type {HTMLElement | null} */ (document.getElementById('recent-next-meta'));
    const recentlyPlayedHint = /** @type {HTMLElement | null} */ (document.getElementById('recently-played-hint'));
    const recentlyPlayedHintDefault = recentlyPlayedHint?.textContent || 'Waiting for station metadata…';
    const recentlyPlayedHintUpdated = 'Updated just now';
    const historyListEl = /** @type {HTMLUListElement | null} */ (document.getElementById('recent-history'));
    const historyDefaultMessage = historyListEl?.dataset?.defaultMessage || 'Waiting for station metadata…';
    const defaultTrackTitle = 'Waiting for metadata';
    const defaultTrackMeta = 'Tune in to update';
    const HISTORY_REFRESH_INTERVAL = 60000;
    let lastHistoryFetch = 0;
    let lastNowPlayingText = null;
    let lastHistoryRenderedSignature = null;
    let historyDisabled = !playerConfig.historyEndpoint;

    /**
     * @param {string} text
     */
    const setStatus = (text) => {
      if (statusText) {
        statusText.textContent = text;
      }
    };

    /**
     * @param {number} percent
     */
    const setBuffer = (percent) => {
      if (!bufferBar) return;
      const safe = Math.max(0, Math.min(100, percent));
      bufferBar.style.width = `${safe}%`;
    };

    const setTrackCard = (titleEl, metaEl, info) => {
      if (!titleEl || !metaEl) return;
      if (info && info.primary) {
        titleEl.textContent = info.primary;
        metaEl.textContent = info.meta || defaultTrackMeta;
      } else {
        titleEl.textContent = defaultTrackTitle;
        metaEl.textContent = defaultTrackMeta;
      }
    };

    const setHistoryMessage = (message) => {
      if (!historyListEl) return;
      historyListEl.innerHTML = '';
      const placeholder = document.createElement('li');
      placeholder.className = 'small-muted';
      placeholder.textContent = message;
      historyListEl.appendChild(placeholder);
      lastHistoryRenderedSignature = null;
    };

    const resetHistoryList = () => {
      setHistoryMessage(historyDefaultMessage);
    };

    const resetTrackCards = () => {
      setTrackCard(previousTitleEl, previousMetaEl, null);
      setTrackCard(nextTitleEl, nextMetaEl, null);
      if (recentlyPlayedHint) {
        recentlyPlayedHint.textContent = recentlyPlayedHintDefault;
      }
    };

    const gatherSongHistory = (payload) => {
      if (!payload || typeof payload !== 'object') {
        return [];
      }

      const collected = [];
      const pushEntry = (source) => {
        if (!source) return;
        const clone = { ...source };
        const playedAt = clone.played_at ?? clone.playedat ?? clone.playedat_ts ?? clone.played ?? clone.timestamp ?? clone.date;
        if (playedAt && !clone.played_at) {
          clone.played_at = playedAt;
        }
        if (!clone.time && clone.played_at) {
          clone.time = clone.played_at;
        }
        if (clone.song && typeof clone.song === 'string') {
          clone.song = { text: clone.song };
        }
        collected.push(clone);
      };

      const candidates = [
        Array.isArray(payload.song_history) ? payload.song_history : null,
        Array.isArray(payload.songhistory) ? payload.songhistory : null,
        Array.isArray(payload.history) ? payload.history : null,
      ];

      candidates.forEach((items) => {
        if (!items) return;
        items.forEach((entry) => pushEntry(entry));
      });

      return collected;
    };

    const toDate = (value) => {
      if (!value) return null;
      if (typeof value === 'number') {
        const ms = value > 1e12 ? value : value * 1000;
        const date = new Date(ms);
        return Number.isNaN(date.getTime()) ? null : date;
      }
      if (typeof value === 'string') {
        const date = new Date(value);
        return Number.isNaN(date.getTime()) ? null : date;
      }
      return null;
    };

    const formatSongEntry = (entry) => {
      if (!entry) return null;
      const base = entry.song ? { ...entry.song } : { ...entry };
      if (!base) return null;

      const playedAt = entry.played_at ?? entry.timestamp ?? entry.time ?? entry.played ?? entry.cued_at ?? base.played_at;
      if (playedAt && !base.played_at) {
        base.played_at = playedAt;
      }

      const primaryCandidates = [
        typeof base.text === 'string' ? base.text.trim() : '',
        [base.artist, base.title].filter((part) => typeof part === 'string' && part.trim()).join(' – '),
        typeof base.title === 'string' ? base.title.trim() : '',
        typeof base.name === 'string' ? base.name.trim() : '',
        typeof base.song === 'string' ? base.song.trim() : '',
      ].map((value) => value && value.trim()).filter(Boolean);

      const primary = primaryCandidates.find((candidate) => candidate && candidate.length > 0) || null;

      const metaParts = [];
      const artistTitle = [base.artist, base.title]
        .filter((part) => typeof part === 'string' && part.trim())
        .join(' · ');
      if (artistTitle && artistTitle !== primary) {
        metaParts.push(artistTitle);
      } else if (typeof base.artist === 'string' && base.artist.trim() && base.artist.trim() !== primary) {
        metaParts.push(base.artist.trim());
      }

      if (typeof base.album === 'string' && base.album.trim()) {
        metaParts.push(base.album.trim());
      }

      const playedDate = toDate(base.played_at ?? entry.cued_at_timestamp);
      if (playedDate) {
        metaParts.push(playedDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
      }

      const meta = metaParts.length > 0 ? metaParts.join(' · ') : null;

      if (!primary && !meta) {
        return null;
      }

      return { primary: primary || meta || null, meta };
    };

    const updateHistoryList = (payload) => {
      if (!historyListEl) return false;
      const historyEntries = gatherSongHistory(payload);
      const rendered = historyEntries
        .map((entry) => formatSongEntry(entry))
        .filter((info) => Boolean(info));

      if (rendered.length === 0) {
        setHistoryMessage(historyDefaultMessage);
        return false;
      }

      const signature = JSON.stringify(rendered);
      if (signature === lastHistoryRenderedSignature) {
        return historyListEl.children.length > 0;
      }

      historyListEl.innerHTML = '';
      rendered.forEach((info, index) => {
        if (!info) return;
        const item = document.createElement('li');
        const classes = ['py-2'];
        if (index) {
          classes.push('border-top', 'border-light-subtle');
        }
        item.className = classes.join(' ');

        const title = document.createElement('div');
        title.className = 'fw-semibold';
        title.textContent = info.primary || historyDefaultMessage;
        item.appendChild(title);

        if (info.meta) {
          const meta = document.createElement('div');
          meta.className = 'small-muted';
          meta.textContent = info.meta;
          item.appendChild(meta);
        }

        historyListEl.appendChild(item);
      });

      lastHistoryRenderedSignature = signature;
      return historyListEl.children.length > 0;
    };

    const extractRecentTracks = (payload) => {
      if (!payload || typeof payload !== 'object') {
        return { previous: null, next: null };
      }

      const previousCandidates = gatherSongHistory(payload);
      if (Array.isArray(payload.previous_tracks)) previousCandidates.push(...payload.previous_tracks);

      const nextCandidates = [];
      if (payload.playing_next) nextCandidates.push(payload.playing_next);
      if (payload.next_track) nextCandidates.push(payload.next_track);
      if (Array.isArray(payload.queue)) nextCandidates.push(...payload.queue);

      const previous = previousCandidates.map((entry) => formatSongEntry(entry)).find(Boolean) || null;
      const next = nextCandidates.map((entry) => formatSongEntry(entry)).find(Boolean) || null;

      return { previous, next };
    };

    const applyRecentTracks = (payload) => {
      if (!previousTitleEl || !previousMetaEl || !nextTitleEl || !nextMetaEl) {
        updateHistoryList(payload);
        return false;
      }

      const { previous, next } = extractRecentTracks(payload);
      setTrackCard(previousTitleEl, previousMetaEl, previous);
      setTrackCard(nextTitleEl, nextMetaEl, next);

      const historyUpdated = updateHistoryList(payload);
      const cardsUpdated = Boolean(previous?.primary) || Boolean(next?.primary);

      if (recentlyPlayedHint) {
        if ((previous && previous.primary) || (next && next.primary) || historyUpdated) {
          recentlyPlayedHint.textContent = recentlyPlayedHintUpdated;
        } else {
          recentlyPlayedHint.textContent = recentlyPlayedHintDefault;
        }
      }

      return historyUpdated || cardsUpdated;
    };

    resetHistoryList();

    if (!playerConfig.hasStream) {
      setStatus('Unavailable');
      btnPlay?.setAttribute('disabled', 'true');
      btnStop?.setAttribute('disabled', 'true');
    }

    if (playerConfig.hasStream && audio && btnPlay && btnStop) {
      btnPlay.addEventListener('click', async () => {
        try {
          setStatus('Connecting');
          await audio.play();
        } catch (err) {
          setStatus('Play blocked');
          console.error(err);
        }
      });

      btnStop.addEventListener('click', () => {
        audio.pause();
        audio.currentTime = 0;
        setStatus('Stopped');
        setBuffer(0);
      });

      volume?.addEventListener('input', (event) => {
        const target = event.currentTarget;
        if (target instanceof HTMLInputElement) {
          audio.volume = Number(target.value);
        }
      });

      audio.addEventListener('playing', () => setStatus('Playing'));
      audio.addEventListener('pause', () => setStatus('Paused'));
      audio.addEventListener('waiting', () => setStatus('Buffering'));
      audio.addEventListener('ended', () => setStatus('Ended'));
      audio.addEventListener('error', () => setStatus('Stream error'));

      let seconds = 0;
      setInterval(() => {
        if (!audio.paused && !audio.ended) {
          seconds += 1;
          const mm = String(Math.floor(seconds / 60)).padStart(2, '0');
          const ss = String(seconds % 60).padStart(2, '0');
          if (timeHint) {
            timeHint.textContent = `${mm}:${ss}`;
          }
        }
      }, 1000);

      audio.addEventListener('progress', () => {
        try {
          if (audio.buffered.length) {
            const end = audio.buffered.end(audio.buffered.length - 1);
            const current = audio.currentTime || 0;
            const delta = Math.max(0, end - current);
            setBuffer(Math.min(100, (delta / 20) * 100));
          }
        } catch (error) {
          console.error(error);
        }
      });
    }

    btnCopyLink?.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(playerConfig.shareUrl);
        setStatus(playerConfig.hasStream ? 'Link copied' : 'Copied');
        setTimeout(() => setStatus(playerConfig.hasStream ? 'Idle' : 'Unavailable'), 1200);
      } catch (error) {
        console.error(error);
      }
    });

    btnReport?.addEventListener('click', () => {
      alert('Thanks. Please describe the issue on the report page.');
    });

    btnShare?.addEventListener('click', async () => {
      try {
        if (navigator.share) {
          await navigator.share({
            title: playerConfig.shareTitle,
            text: playerConfig.shareText,
            url: playerConfig.shareUrl,
          });
        } else {
          await navigator.clipboard.writeText(playerConfig.shareUrl);
          setStatus('Link copied');
          setTimeout(() => setStatus(playerConfig.hasStream ? 'Idle' : 'Unavailable'), 1200);
        }
      } catch (error) {
        console.error(error);
      }
    });

    btnFavorite?.addEventListener('click', (event) => {
      const target = event.currentTarget;
      if (!(target instanceof HTMLElement)) return;
      const icon = target.querySelector('i');
      if (!icon) return;
      const isFav = icon.classList.contains('bi-heart-fill');
      icon.classList.toggle('bi-heart', isFav);
      icon.classList.toggle('bi-heart-fill', !isFav);
      setStatus(!isFav ? 'Saved to favorites' : 'Removed from favorites');
      setTimeout(() => setStatus(playerConfig.hasStream ? 'Idle' : 'Unavailable'), 1200);
    });

    btnVote?.addEventListener('click', () => {
      alert('Vote submitted. Thank you.');
    });

    const extractNowPlayingText = (payload) => {
      if (!payload) return null;

      if (payload.icestats) {
        const sourceData = (() => {
          const { source } = payload.icestats;
          if (Array.isArray(source)) {
            return source.find((entry) => entry && (entry.yp_currently_playing || entry.title || entry.songtitle)) || source[0];
          }
          return source;
        })();

        if (sourceData) {
          const { yp_currently_playing, title, songtitle, artist, server_name } = sourceData;
          const candidates = [yp_currently_playing, title, songtitle]
            .concat(artist && title ? `${artist} – ${title}` : null)
            .concat(server_name && title ? `${server_name} – ${title}` : null)
            .filter((value) => typeof value === 'string' && value.trim());
          const resolved = candidates.find((value) => Boolean(value?.trim()));
          if (resolved) {
            return resolved.trim();
          }
        }
      }

      if (Array.isArray(payload.data) && payload.data.length > 0) {
        const entry = payload.data[0];
        if (entry) {
          if (typeof entry.song === 'string' && entry.song.trim()) {
            return entry.song.trim();
          }
          if (entry.track) {
            const { artist, title } = entry.track;
            const candidates = [artist, title].filter((value) => typeof value === 'string' && value.trim());
            if (candidates.length > 0) {
              return candidates.join(' – ');
            }
          }
          if (typeof entry.summary === 'string' && entry.summary.trim()) {
            const summary = entry.summary.replace(/<[^>]+>/g, '').trim();
            if (summary) return summary;
          }
        }
      }

      if (payload.now_playing?.song) {
        const { artist, title, text } = payload.now_playing.song;
        if (text) return text;
        const parts = [];
        if (artist) parts.push(artist);
        if (title) parts.push(title);
        if (parts.length > 0) return parts.join(' – ');
      }

      if (payload.current_track) {
        const { artist, title } = payload.current_track;
        if (artist || title) {
          return [artist, title].filter(Boolean).join(' – ');
        }
      }

      if (Array.isArray(payload.now_playing) && payload.now_playing.length > 0) {
        const entry = payload.now_playing[0];
        const { artist, title, song } = entry;
        if (song) return song;
        if (artist || title) return [artist, title].filter(Boolean).join(' – ');
      }

      if (typeof payload.title === 'string' && payload.title.trim()) {
        return payload.title.trim();
      }

      if (typeof payload.song === 'string' && payload.song.trim()) {
        return payload.song.trim();
      }

      if (payload.artist || payload.track) {
        return [payload.artist, payload.track].filter(Boolean).join(' – ');
      }

      if (typeof payload.songtitle === 'string' && payload.songtitle.trim()) {
        return payload.songtitle.trim();
      }

      const text = payload.text || payload.message;
      if (typeof text === 'string' && text.trim()) {
        return text.trim();
      }

      return null;
    };

    const parseNowPlayingResponse = async (response) => {
      const contentType = response.headers?.get?.('content-type') || '';
      if (contentType && contentType.includes('application/json')) {
        try {
          return await response.json();
        } catch (error) {
          console.error('Failed to parse JSON response', error);
        }
      }

      try {
        const rawText = await response.text();
        if (!rawText) {
          return null;
        }

        const trimmed = rawText.trim();
        const bracesIndex = trimmed.indexOf('{');
        const bracketIndex = trimmed.indexOf('[');
        const candidateIndices = [bracesIndex, bracketIndex].filter((index) => index >= 0);
        const jsonStart = candidateIndices.length > 0 ? Math.min(...candidateIndices) : -1;
        const payload = jsonStart > 0 ? trimmed.slice(jsonStart) : trimmed;

        return JSON.parse(payload);
      } catch (error) {
        console.error('Failed to parse text response', error);
        return null;
      }
    };

    const parseHistoryEntries = (rawText, type) => {
      if (!rawText) return [];
      const cleanedText = rawText.replace(/\r/g, '');
      const lines = cleanedText.split('\n').map((line) => line.trim()).filter(Boolean);

      if (type === 'icecast') {
        const currentLine = lines.find((line) => /^current song[:：]/i.test(line));
        if (currentLine) {
          const title = currentLine.replace(/^[^:]+:\s*/, '').trim();
          if (title) {
            return [{ time: null, title }];
          }
        }
        return [];
      }

      const timePattern = /^(\d{2}:\d{2}:\d{2})/;
      const entries = [];

      lines.forEach((line) => {
        const match = line.match(timePattern);
        if (!match) return;
        let title = line.slice(match[0].length).trim();
        title = title.replace(/\*\*Current Song\*\*/gi, '').replace(/Current Song/gi, '').trim();
        title = title.replace(/^[-–—\s]+/, '').trim();
        title = title.replace(/\*{2}/g, '').trim();
        if (!title) return;
        entries.push({ time: match[1], title });
      });

      return entries;
    };

    const fetchAndApplyHistory = async (options = {}) => {
      if (!playerConfig.historyEndpoint || historyDisabled) return false;

      const force = Boolean(options.force);
      const now = Date.now();
      if (!force && lastHistoryFetch && now - lastHistoryFetch < HISTORY_REFRESH_INTERVAL) {
        return false;
      }

      try {
        const response = await fetch(playerConfig.historyEndpoint, { cache: 'no-store' });
        if (!response.ok) throw new Error(`${response.status} ${response.statusText}`);
        const contentType = response.headers?.get?.('content-type') || '';

        if (contentType.includes('application/json')) {
          try {
            const jsonPayload = await response.json();
            const historyApplied = applyRecentTracks(jsonPayload);
            const fallbackText = extractNowPlayingText(jsonPayload);
            if (fallbackText && nowPlayingEl && nowPlayingEl.textContent !== fallbackText) {
              nowPlayingEl.textContent = fallbackText;
            }
            lastHistoryFetch = Date.now();
            if (historyApplied) {
              historyDisabled = false;
            }
            return historyApplied;
          } catch (parseError) {
            console.error('Failed to parse JSON history response', parseError);
            lastHistoryFetch = Date.now();
            if (playerConfig.serverType === 'shoutcast') {
              historyDisabled = true;
            }
            return false;
          }
        }

        const raw = await response.text();
        const entries = parseHistoryEntries(raw, playerConfig.serverType || 'unknown');
        if (!entries.length) {
          lastHistoryFetch = Date.now();
          if (playerConfig.serverType === 'shoutcast') {
            historyDisabled = true;
          }
          return false;
        }

        const [current, ...rest] = entries;
        const historyEntries = rest.map((entry) => ({
          text: entry.title,
          played_at: entry.time,
          time: entry.time,
        }));

        const fallbackPayload = {};
        if (current && current.title) {
          fallbackPayload.now_playing = { song: { text: current.title } };
        }
        if (historyEntries.length > 0) {
          fallbackPayload.song_history = historyEntries;
        }

        const historyApplied = historyEntries.length > 0 ? applyRecentTracks(fallbackPayload) : false;

        const fallbackText = extractNowPlayingText(fallbackPayload);
        let updatedNowPlaying = false;
        if (fallbackText && nowPlayingEl && nowPlayingEl.textContent !== fallbackText) {
          nowPlayingEl.textContent = fallbackText;
          updatedNowPlaying = true;
        }

        const result = historyApplied || updatedNowPlaying;
        lastHistoryFetch = Date.now();
        historyDisabled = false;
        return result;
      } catch (error) {
        console.error('History request failed', error);
        lastHistoryFetch = Date.now();
        if (playerConfig.serverType === 'shoutcast') {
          historyDisabled = true;
        }
        return false;
      }
    };

    const pollNowPlaying = async () => {
      if (!playerConfig.nowPlayingEndpoint || !nowPlayingEl) return;

      try {
        const response = await fetch(playerConfig.nowPlayingEndpoint, { cache: 'no-store' });
        if (!response.ok) throw new Error(`${response.status} ${response.statusText}`);
        const data = await parseNowPlayingResponse(response);
        if (!data) {
          throw new Error('Empty now playing payload');
        }
        const text = extractNowPlayingText(data);
        const textChanged = Boolean(text && text !== lastNowPlayingText);
        if (text && nowPlayingEl.textContent !== text) {
          nowPlayingEl.textContent = text;
        }
        if (text) {
          lastNowPlayingText = text;
        }
        const historyApplied = applyRecentTracks(data);
        if (!historyApplied && !historyDisabled) {
          await fetchAndApplyHistory({ force: textChanged });
        }
      } catch (error) {
        console.error('Now playing request failed', error);
        if (nowPlayingEl.textContent !== nowPlayingDefault) {
          nowPlayingEl.textContent = nowPlayingDefault;
        }
        resetTrackCards();
        resetHistoryList();
        lastNowPlayingText = null;
        lastHistoryFetch = 0;
        historyDisabled = historyDisabled || !playerConfig.historyEndpoint;
      }
    };

    if (playerConfig.nowPlayingEndpoint) {
      pollNowPlaying();
      setInterval(pollNowPlaying, 20000);
    }
  </script>
</Layout>